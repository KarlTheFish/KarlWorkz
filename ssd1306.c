#include <string.h> // memset
#include "ssd1306.h"
#include "i2c_helper.h"

#define SSD1306_ADDR    0x3C   // slave address (3C for 128x32, 3D for 128x64)
#define CTRL_BYTE       0x00   // control that allows to send the command to the screen
#define DATA_BYTE       0x40   // next coming byte is a data on the screen

#define FONT_SIZE       5
#define ASCII_SYMBOLS   96
#define CHAR_OFFSET     32     // offset used for the ascii font

#define CACHE_SIZE (SSD1306_LCDWIDTH * (SSD1306_LCDHEIGHT / PAGES))

#define SIZE(arr) (sizeof(arr) / sizeof(arr[0]))

// 5x8 font (turned over)
const uint8_t ascii[ASCII_SYMBOLS][FONT_SIZE] = {
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 20
  {0x00, 0x00, 0x5f, 0x00, 0x00}, // 21 !
  {0x00, 0x07, 0x00, 0x07, 0x00}, // 22 "
  {0x14, 0x7f, 0x14, 0x7f, 0x14}, // 23 #
  {0x24, 0x2a, 0x7f, 0x2a, 0x12}, // 24 $
  {0x23, 0x13, 0x08, 0x64, 0x62}, // 25 %
  {0x36, 0x49, 0x55, 0x22, 0x50}, // 26 &
  {0x00, 0x05, 0x03, 0x00, 0x00}, // 27 '
  {0x00, 0x1c, 0x22, 0x41, 0x00}, // 28 (
  {0x00, 0x41, 0x22, 0x1c, 0x00}, // 29 )
  {0x14, 0x08, 0x3e, 0x08, 0x14}, // 2a *
  {0x08, 0x08, 0x3e, 0x08, 0x08}, // 2b +
  {0x00, 0x50, 0x30, 0x00, 0x00}, // 2c ,
  {0x08, 0x08, 0x08, 0x08, 0x08}, // 2d -
  {0x00, 0x60, 0x60, 0x00, 0x00}, // 2e .
  {0x20, 0x10, 0x08, 0x04, 0x02}, // 2f /
  {0x3e, 0x51, 0x49, 0x45, 0x3e}, // 30 0
  {0x00, 0x42, 0x7f, 0x40, 0x00}, // 31 1
  {0x42, 0x61, 0x51, 0x49, 0x46}, // 32 2
  {0x21, 0x41, 0x45, 0x4b, 0x31}, // 33 3
  {0x18, 0x14, 0x12, 0x7f, 0x10}, // 34 4
  {0x27, 0x45, 0x45, 0x45, 0x39}, // 35 5
  {0x3c, 0x4a, 0x49, 0x49, 0x30}, // 36 6
  {0x01, 0x71, 0x09, 0x05, 0x03}, // 37 7
  {0x36, 0x49, 0x49, 0x49, 0x36}, // 38 8
  {0x06, 0x49, 0x49, 0x29, 0x1e}, // 39 9
  {0x00, 0x00, 0x66, 0x66, 0x00}, // 3a :
  {0x00, 0x56, 0x36, 0x00, 0x00}, // 3b ;
  {0x08, 0x14, 0x22, 0x41, 0x00}, // 3c <
  {0x14, 0x14, 0x14, 0x14, 0x14}, // 3d =
  {0x00, 0x41, 0x22, 0x14, 0x08}, // 3e >
  {0x02, 0x01, 0x51, 0x09, 0x06}, // 3f ?
  {0x32, 0x49, 0x79, 0x41, 0x3e}, // 40 @
  {0x7e, 0x11, 0x11, 0x11, 0x7e}, // 41 A
  {0x7f, 0x49, 0x49, 0x49, 0x36}, // 42 B
  {0x3e, 0x41, 0x41, 0x41, 0x22}, // 43 C
  {0x7f, 0x41, 0x41, 0x22, 0x1c}, // 44 D
  {0x7f, 0x49, 0x49, 0x49, 0x41}, // 45 E
  {0x7f, 0x09, 0x09, 0x09, 0x01}, // 46 F
  {0x3e, 0x41, 0x49, 0x49, 0x7a}, // 47 G
  {0x7f, 0x08, 0x08, 0x08, 0x7f}, // 48 H
  {0x00, 0x41, 0x7f, 0x41, 0x00}, // 49 I
  {0x20, 0x40, 0x41, 0x3f, 0x01}, // 4a J
  {0x7f, 0x08, 0x14, 0x22, 0x41}, // 4b K
  {0x7f, 0x40, 0x40, 0x40, 0x40}, // 4c L
  {0x7f, 0x02, 0x0c, 0x02, 0x7f}, // 4d M
  {0x7f, 0x04, 0x08, 0x10, 0x7f}, // 4e N
  {0x3e, 0x41, 0x41, 0x41, 0x3e}, // 4f O
  {0x7f, 0x09, 0x09, 0x09, 0x06}, // 50 P
  {0x3e, 0x41, 0x51, 0x21, 0x5e}, // 51 Q
  {0x7f, 0x09, 0x19, 0x29, 0x46}, // 52 R
  {0x46, 0x49, 0x49, 0x49, 0x31}, // 53 S
  {0x01, 0x01, 0x7f, 0x01, 0x01}, // 54 T
  {0x3f, 0x40, 0x40, 0x40, 0x3f}, // 55 U
  {0x1f, 0x20, 0x40, 0x20, 0x1f}, // 56 V
  {0x3f, 0x40, 0x38, 0x40, 0x3f}, // 57 W
  {0x63, 0x14, 0x08, 0x14, 0x63}, // 58 X
  {0x07, 0x08, 0x70, 0x08, 0x07}, // 59 Y
  {0x61, 0x51, 0x49, 0x45, 0x43}, // 5a Z
  {0x00, 0x7f, 0x41, 0x41, 0x00}, // 5b [
  {0x02, 0x04, 0x08, 0x10, 0x20}, // 5c '\'
  {0x00, 0x41, 0x41, 0x7f, 0x00}, // 5d ]
  {0x04, 0x02, 0x01, 0x02, 0x04}, // 5e ^
  {0x40, 0x40, 0x40, 0x40, 0x40}, // 5f _
  {0x00, 0x01, 0x02, 0x04, 0x00}, // 60 `
  {0x20, 0x54, 0x54, 0x54, 0x78}, // 61 a
  {0x7f, 0x48, 0x44, 0x44, 0x38}, // 62 b
  {0x38, 0x44, 0x44, 0x44, 0x20}, // 63 c
  {0x38, 0x44, 0x44, 0x48, 0x7f}, // 64 d
  {0x38, 0x54, 0x54, 0x54, 0x18}, // 65 e
  {0x08, 0x7e, 0x09, 0x01, 0x02}, // 66 f
  {0x0c, 0x52, 0x52, 0x52, 0x3e}, // 67 g
  {0x7f, 0x08, 0x04, 0x04, 0x78}, // 68 h
  {0x00, 0x44, 0x7d, 0x40, 0x00}, // 69 i
  {0x20, 0x40, 0x44, 0x3d, 0x00}, // 6a j
  {0x7f, 0x10, 0x28, 0x44, 0x00}, // 6b k
  {0x00, 0x41, 0x7f, 0x40, 0x00}, // 6c l
  {0x7c, 0x04, 0x18, 0x04, 0x78}, // 6d m
  {0x7c, 0x08, 0x04, 0x04, 0x78}, // 6e n
  {0x38, 0x44, 0x44, 0x44, 0x38}, // 6f o
  {0x7c, 0x14, 0x14, 0x14, 0x08}, // 70 p
  {0x08, 0x14, 0x14, 0x18, 0x7c}, // 71 q
  {0x7c, 0x08, 0x04, 0x04, 0x08}, // 72 r
  {0x48, 0x54, 0x54, 0x54, 0x20}, // 73 s
  {0x04, 0x3f, 0x44, 0x40, 0x20}, // 74 t
  {0x3c, 0x40, 0x40, 0x20, 0x7c}, // 75 u
  {0x1c, 0x20, 0x40, 0x20, 0x1c}, // 76 v
  {0x3c, 0x40, 0x30, 0x40, 0x3c}, // 77 w
  {0x44, 0x28, 0x10, 0x28, 0x44}, // 78 x
  {0x0c, 0x50, 0x50, 0x50, 0x3c}, // 79 y
  {0x44, 0x64, 0x54, 0x4c, 0x44}, // 7a z
  {0x00, 0x08, 0x36, 0x41, 0x00}, // 7b {
  {0x00, 0x00, 0x7f, 0x00, 0x00}, // 7c |
  {0x00, 0x41, 0x36, 0x08, 0x00}, // 7d }
  {0x10, 0x08, 0x08, 0x10, 0x08}, // 7e ->
  {0x78, 0x46, 0x41, 0x46, 0x78}  // 7f <-
};

uint8_t cache[CACHE_SIZE];
size_t cache_cursor = 0;

void SendCommand(uint8_t cmd) {
    SendSingleByte(SSD1306_ADDR, CTRL_BYTE, cmd);
}

// Init sequence for 128x64 OLED module
void DisplayInit(void) {
    SendCommand(SSD1306_DISPLAYOFF);

    SendCommand(SSD1306_SETDISPLAYCLOCKDIV);
    SendCommand(0x80);                              // the suggested ratio 0x80

    SendCommand(SSD1306_SETMULTIPLEX);
    SendCommand(0x3F);    // 0 - 32

    SendCommand(SSD1306_SETDISPLAYOFFSET);
    SendCommand(0x00);                              // no offset

    SendCommand(SSD1306_SETSTARTLINE);// | 0x0);    // line #0

    SendCommand(SSD1306_MEMORYMODE); 
    SendCommand(0x00);

    SendCommand(SSD1306_CHARGEPUMP);
    SendCommand(0x14);                              // using internal VCC

    SendCommand(SSD1306_SEGREMAP | 0xA1);           // Set Segment Re-Map
    SendCommand(SSD1306_COMSCANDEC);                // Set Com Output Scan Direction

    SendCommand(SSD1306_SETCOMPINS);
    SendCommand(0x12);

    SendCommand(SSD1306_SETCONTRAST);
    SendCommand(0xCF);                              // from 0x00 - 0xFF

    SendCommand(SSD1306_SETPRECHARGE);
    SendCommand(0xF1);

    SendCommand(SSD1306_SETVCOMDETECT);
    SendCommand(0x20);

    SendCommand(SSD1306_DEACTIVATE_SCROLL);

    SendCommand(SSD1306_DISPLAYALLON_RESUME);

    SendCommand(SSD1306_NORMALDISPLAY);

    SendCommand(SSD1306_DISPLAYON);

    // page is y (0-7), col is x (0-15)
    // Set cursor of the display at 0, 0
    SendCommand(0xB0);  // set page address     (B0-B7)
    SendCommand(0x00);  // set low col address  (00-0F)
    SendCommand(0x10);  // set high col address (10-1F)
}

void DisplayOn(void) {
    SendCommand(SSD1306_DISPLAYON);
}

void DisplayOff(void) {
    SendCommand(SSD1306_DISPLAYOFF);
}

void DisplayClear(void) {
    memset(cache, 0x00, CACHE_SIZE);
}

void DisplayUpdate(void) {
    SendMultipleBytes(SSD1306_ADDR, DATA_BYTE, cache, SIZE(cache));
}

bool IsInLimits(uint8_t val1, uint8_t limit1, uint8_t val2, uint8_t limit2) {
    return (val1 >= 0 && val1 < limit1 && val2 >= 0 && val2 < limit2);
}

// col (0-127), page (0-7)
void SetCursor(uint8_t col, uint8_t page) {
    if (!IsInLimits(col, SSD1306_LCDWIDTH, page, PAGES)) { return; }
    cache_cursor = page * SSD1306_LCDWIDTH + col;
}

// x (0-127), y (0-63)
// clear_pixel -> true, then removes rather than draw
void DrawPixel(uint8_t x, uint8_t y, bool clear_pixel) {
    if (!IsInLimits(x, SSD1306_LCDWIDTH, y, SSD1306_LCDHEIGHT)) { return; }
    uint8_t page = y / PAGE_SIZE;
    uint8_t pixel_pos = 1 << (y % PAGE_SIZE);
    if (clear_pixel) {
        cache[page * SSD1306_LCDWIDTH + x] &= ~pixel_pos;
    } else {
        cache[page * SSD1306_LCDWIDTH + x] |= pixel_pos;
    }
}

// swaps variables so max of both is in val2
void Swap(uint8_t* val1, uint8_t* val2) {
    if (*val1 > *val2) {
        uint8_t temp = *val1;
        *val1 = *val2;
        *val2 = temp;
    }
}

void DrawVerticalLine(uint8_t x, uint8_t y1, uint8_t y2) {
    for (Swap(&y1, &y2); y1 <= y2; y1++) {
        DrawPixel(x, y1, false);
    }
}

void DrawHorizontalLine(uint8_t y, uint8_t x1, uint8_t x2) {
    for (Swap(&x1, &x2); x1 <= x2; x1++) {
        DrawPixel(x1, y, false);
    }
}

void DrawChar(uint8_t ch) {
    if (ch < CHAR_OFFSET || ch > ASCII_SYMBOLS + CHAR_OFFSET - 1) { return; }
    for (uint8_t i = 0; i < SIZE(ascii[ch - CHAR_OFFSET]); i++) {
        cache[cache_cursor] = ascii[ch - CHAR_OFFSET][i];
        cache_cursor++;
        if (cache_cursor >= CACHE_SIZE) {
            cache_cursor = 0;
        }
    }
}

// Currently wraps around
void DrawStr(const char* str) {
    for (; *str; str++) {
        DrawChar(*str);
    } 
}